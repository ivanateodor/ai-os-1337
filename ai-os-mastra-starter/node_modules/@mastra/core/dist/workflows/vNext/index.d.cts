import { g as ExecutionEngine, h as StepResult, i as ExecutionGraph, j as StepFlowEntry, N as NewStep, k as ExecuteFunction } from '../../base-CAEcd6q2.cjs';
export { D as DynamicMapping, z as ExtractSchemaFromStep, y as ExtractSchemaType, t as NewWorkflow, s as NewWorkflowConfig, P as PathsToStringProps, R as Run, l as SerializedStep, m as SerializedStepFlowEntry, v as StepFailure, u as StepSuccess, w as StepSuspended, x as StepsRecord, V as VariableReference, B as WatchEvent, r as WorkflowResult, Z as ZodPathType, o as cloneStep, q as cloneWorkflow, n as createStep, p as createWorkflow } from '../../base-CAEcd6q2.cjs';
import { Span } from '@opentelemetry/api';
import { RuntimeContext } from '../../runtime-context/index.cjs';
import 'ai';
import '../../base-H7siSAfu.cjs';
import '../../index-QV27jkxQ.cjs';
import 'stream';
import 'pino';
import '@opentelemetry/sdk-trace-base';
import '../../types-BtMyV38I.cjs';
import 'sift';
import 'zod';
import 'json-schema';
import 'xstate';
import 'node:events';
import '../../vector/index.cjs';
import '../../vector/filter/index.cjs';
import '../../tts/index.cjs';
import 'node:http';
import 'hono';
import 'events';
import '../../deployer/index.cjs';
import '../../bundler/index.cjs';
import 'hono/cors';
import 'hono-openapi';
import 'ai/test';

type ExecutionContext = {
    workflowId: string;
    runId: string;
    executionPath: number[];
    suspendedPaths: Record<string, number[]>;
    retryConfig: {
        attempts: number;
        delay: number;
    };
    executionSpan: Span;
};
/**
 * Default implementation of the ExecutionEngine using XState
 */
declare class DefaultExecutionEngine extends ExecutionEngine {
    protected fmtReturnValue<TOutput>(executionSpan: Span | undefined, emitter: {
        emit: (event: string, data: any) => Promise<void>;
    }, stepResults: Record<string, StepResult<any>>, lastOutput: StepResult<any>, error?: Error | string): Promise<TOutput>;
    /**
     * Executes a workflow run with the provided execution graph and input
     * @param graph The execution graph to execute
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    execute<TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        graph: ExecutionGraph;
        input?: TInput;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any>>;
            resumePayload: any;
            resumePath: number[];
        };
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        runtimeContext: RuntimeContext;
    }): Promise<TOutput>;
    getStepOutput(stepResults: Record<string, any>, step?: StepFlowEntry): any;
    executeStep({ workflowId, runId, step, stepResults, executionContext, resume, prevOutput, emitter, runtimeContext, }: {
        workflowId: string;
        runId: string;
        step: NewStep<string, any, any>;
        stepResults: Record<string, StepResult<any>>;
        executionContext: ExecutionContext;
        resume?: {
            steps: string[];
            resumePayload: any;
        };
        prevOutput: any;
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any>>;
    executeParallel({ workflowId, runId, entry, prevStep, stepResults, resume, executionContext, emitter, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'parallel';
            steps: StepFlowEntry[];
        };
        prevStep: StepFlowEntry;
        stepResults: Record<string, StepResult<any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any>>;
    executeConditional({ workflowId, runId, entry, prevOutput, prevStep, stepResults, resume, executionContext, emitter, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'conditional';
            steps: StepFlowEntry[];
            conditions: ExecuteFunction<any, any, any, any>[];
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any>>;
    executeLoop({ workflowId, runId, entry, prevOutput, stepResults, resume, executionContext, emitter, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'loop';
            step: NewStep;
            condition: ExecuteFunction<any, any, any, any>;
            loopType: 'dowhile' | 'dountil';
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any>>;
    executeForeach({ workflowId, runId, entry, prevOutput, stepResults, resume, executionContext, emitter, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'foreach';
            step: NewStep;
            opts: {
                concurrency: number;
            };
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any>>;
    protected persistStepUpdate({ workflowId, runId, stepResults, executionContext, }: {
        workflowId: string;
        runId: string;
        stepResults: Record<string, StepResult<any>>;
        executionContext: ExecutionContext;
    }): Promise<void>;
    executeEntry({ workflowId, runId, entry, prevStep, stepResults, resume, executionContext, emitter, runtimeContext, }: {
        workflowId: string;
        runId: string;
        entry: StepFlowEntry;
        prevStep: StepFlowEntry;
        stepResults: Record<string, StepResult<any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: {
            emit: (event: string, data: any) => Promise<void>;
        };
        runtimeContext: RuntimeContext;
    }): Promise<StepResult<any>>;
}

export { DefaultExecutionEngine, ExecuteFunction, type ExecutionContext, ExecutionEngine, ExecutionGraph, NewStep, StepFlowEntry, StepResult };
