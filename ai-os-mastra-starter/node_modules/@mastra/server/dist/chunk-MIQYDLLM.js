import { stringify, esm_default } from './chunk-LIVAK2DM.js';
import { handleError } from './chunk-M5ABIP7D.js';
import { HTTPException } from './chunk-NYN7KFXL.js';
import { __export } from './chunk-MLKGABMK.js';
import { ReadableStream } from 'node:stream/web';
import { RuntimeContext } from '@mastra/core/di';

// src/server/handlers/vNextWorkflows.ts
var vNextWorkflows_exports = {};
__export(vNextWorkflows_exports, {
  createVNextWorkflowRunHandler: () => createVNextWorkflowRunHandler,
  getVNextWorkflowByIdHandler: () => getVNextWorkflowByIdHandler,
  getVNextWorkflowRunByIdHandler: () => getVNextWorkflowRunByIdHandler,
  getVNextWorkflowRunsHandler: () => getVNextWorkflowRunsHandler,
  getVNextWorkflowsHandler: () => getVNextWorkflowsHandler,
  resumeAsyncVNextWorkflowHandler: () => resumeAsyncVNextWorkflowHandler,
  resumeVNextWorkflowHandler: () => resumeVNextWorkflowHandler,
  startAsyncVNextWorkflowHandler: () => startAsyncVNextWorkflowHandler,
  startVNextWorkflowRunHandler: () => startVNextWorkflowRunHandler,
  watchVNextWorkflowHandler: () => watchVNextWorkflowHandler
});
async function getVNextWorkflowsHandler({ mastra }) {
  try {
    const workflows = mastra.vnext_getWorkflows({ serialized: false });
    const _workflows = Object.entries(workflows).reduce((acc, [key, workflow]) => {
      acc[key] = {
        name: workflow.name,
        steps: Object.entries(workflow.steps).reduce((acc2, [key2, step]) => {
          acc2[key2] = {
            id: step.id,
            description: step.description,
            inputSchema: step.inputSchema ? stringify(esm_default(step.inputSchema)) : void 0,
            outputSchema: step.outputSchema ? stringify(esm_default(step.outputSchema)) : void 0,
            resumeSchema: step.resumeSchema ? stringify(esm_default(step.resumeSchema)) : void 0,
            suspendSchema: step.suspendSchema ? stringify(esm_default(step.suspendSchema)) : void 0
          };
          return acc2;
        }, {}),
        stepGraph: workflow.serializedStepGraph,
        inputSchema: workflow.inputSchema ? stringify(esm_default(workflow.inputSchema)) : void 0,
        outputSchema: workflow.outputSchema ? stringify(esm_default(workflow.outputSchema)) : void 0
      };
      return acc;
    }, {});
    return _workflows;
  } catch (error) {
    throw new HTTPException(500, { message: error?.message || "Error getting workflows" });
  }
}
async function getVNextWorkflowByIdHandler({ mastra, workflowId }) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    if (!workflow) {
      throw new HTTPException(404, { message: "Workflow not found" });
    }
    return {
      steps: Object.entries(workflow.steps).reduce((acc, [key, step]) => {
        acc[key] = {
          id: step.id,
          description: step.description,
          inputSchema: step.inputSchema ? stringify(esm_default(step.inputSchema)) : void 0,
          outputSchema: step.outputSchema ? stringify(esm_default(step.outputSchema)) : void 0,
          resumeSchema: step.resumeSchema ? stringify(esm_default(step.resumeSchema)) : void 0,
          suspendSchema: step.suspendSchema ? stringify(esm_default(step.suspendSchema)) : void 0
        };
        return acc;
      }, {}),
      name: workflow.name,
      stepGraph: workflow.serializedStepGraph,
      inputSchema: workflow.inputSchema ? stringify(esm_default(workflow.inputSchema)) : void 0,
      outputSchema: workflow.outputSchema ? stringify(esm_default(workflow.outputSchema)) : void 0
    };
  } catch (error) {
    throw new HTTPException(500, { message: error?.message || "Error getting workflow" });
  }
}
async function getVNextWorkflowRunByIdHandler({
  mastra,
  workflowId,
  runId
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new HTTPException(400, { message: "Run ID is required" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    if (!workflow) {
      throw new HTTPException(404, { message: "Workflow not found" });
    }
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new HTTPException(404, { message: "Workflow run not found" });
    }
    return run;
  } catch (error) {
    throw new HTTPException(500, { message: error?.message || "Error getting workflow run" });
  }
}
async function createVNextWorkflowRunHandler({
  mastra,
  workflowId,
  runId: prevRunId
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    if (!workflow) {
      throw new HTTPException(404, { message: "Workflow not found" });
    }
    const run = workflow.createRun({ runId: prevRunId });
    return { runId: run.runId };
  } catch (error) {
    throw new HTTPException(500, { message: error?.message || "Error creating workflow run" });
  }
}
async function startAsyncVNextWorkflowHandler({
  mastra,
  runtimeContext,
  workflowId,
  runId,
  inputData,
  runtimeContextFromRequest
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    if (!workflow) {
      throw new HTTPException(404, { message: "Workflow not found" });
    }
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext?.entries() ?? []),
      ...Array.from(Object.entries(runtimeContextFromRequest ?? {}))
    ]);
    const _run = workflow.createRun({ runId });
    const result = await _run.start({
      inputData,
      runtimeContext: finalRuntimeContext
    });
    return result;
  } catch (error) {
    throw new HTTPException(500, { message: error?.message || "Error executing workflow" });
  }
}
async function startVNextWorkflowRunHandler({
  mastra,
  runtimeContext,
  workflowId,
  runId,
  inputData,
  runtimeContextFromRequest
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new HTTPException(400, { message: "runId required to start run" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new HTTPException(404, { message: "Workflow run not found" });
    }
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext?.entries() ?? []),
      ...Array.from(Object.entries(runtimeContextFromRequest ?? {}))
    ]);
    const _run = workflow.createRun({ runId });
    void _run.start({
      inputData,
      runtimeContext: finalRuntimeContext
    });
    return { message: "Workflow run started" };
  } catch (e) {
    return handleError(e, "Error starting workflow run");
  }
}
async function watchVNextWorkflowHandler({
  mastra,
  workflowId,
  runId
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new HTTPException(400, { message: "runId required to watch workflow" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = workflow.createRun({ runId });
    let unwatch;
    let asyncRef = null;
    const stream = new ReadableStream({
      start(controller) {
        unwatch = _run.watch(({ type, payload, eventTimestamp }) => {
          controller.enqueue(JSON.stringify({ type, payload, eventTimestamp, runId }));
          if (asyncRef) {
            clearImmediate(asyncRef);
            asyncRef = null;
          }
          asyncRef = setImmediate(async () => {
            const runDone = payload.workflowState.status !== "running";
            if (runDone) {
              controller.close();
              unwatch?.();
            }
          });
        });
      },
      cancel() {
        unwatch?.();
      }
    });
    return stream;
  } catch (error) {
    return handleError(error, "Error watching workflow");
  }
}
async function resumeAsyncVNextWorkflowHandler({
  mastra,
  workflowId,
  runId,
  body,
  runtimeContext,
  runtimeContextFromRequest
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new HTTPException(400, { message: "runId required to resume workflow" });
    }
    if (!body.step) {
      throw new HTTPException(400, { message: "step required to resume workflow" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new HTTPException(404, { message: "Workflow run not found" });
    }
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext?.entries() ?? []),
      ...Array.from(Object.entries(runtimeContextFromRequest ?? {}))
    ]);
    const _run = workflow.createRun({ runId });
    const result = await _run.resume({
      step: body.step,
      resumeData: body.resumeData,
      runtimeContext: finalRuntimeContext
    });
    return result;
  } catch (error) {
    return handleError(error, "Error resuming workflow step");
  }
}
async function resumeVNextWorkflowHandler({
  mastra,
  workflowId,
  runId,
  body,
  runtimeContext
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    if (!runId) {
      throw new HTTPException(400, { message: "runId required to resume workflow" });
    }
    if (!body.step) {
      throw new HTTPException(400, { message: "step required to resume workflow" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    const run = await workflow.getWorkflowRunById(runId);
    if (!run) {
      throw new HTTPException(404, { message: "Workflow run not found" });
    }
    const _run = workflow.createRun({ runId });
    void _run.resume({
      step: body.step,
      resumeData: body.resumeData,
      runtimeContext
    });
    return { message: "Workflow run resumed" };
  } catch (error) {
    return handleError(error, "Error resuming workflow");
  }
}
async function getVNextWorkflowRunsHandler({
  mastra,
  workflowId,
  fromDate,
  toDate,
  limit,
  offset,
  resourceId
}) {
  try {
    if (!workflowId) {
      throw new HTTPException(400, { message: "Workflow ID is required" });
    }
    const workflow = mastra.vnext_getWorkflow(workflowId);
    const workflowRuns = await workflow.getWorkflowRuns({ fromDate, toDate, limit, offset, resourceId }) || {
      runs: [],
      total: 0
    };
    return workflowRuns;
  } catch (error) {
    return handleError(error, "Error getting workflow runs");
  }
}

export { createVNextWorkflowRunHandler, getVNextWorkflowByIdHandler, getVNextWorkflowRunByIdHandler, getVNextWorkflowRunsHandler, getVNextWorkflowsHandler, resumeAsyncVNextWorkflowHandler, resumeVNextWorkflowHandler, startAsyncVNextWorkflowHandler, startVNextWorkflowRunHandler, vNextWorkflows_exports, watchVNextWorkflowHandler };
