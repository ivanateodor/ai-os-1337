import { stringify, esm_default } from './chunk-LIVAK2DM.js';
import { validateBody } from './chunk-H5PTF3Y4.js';
import { handleError } from './chunk-M5ABIP7D.js';
import { HTTPException } from './chunk-NYN7KFXL.js';
import { __export } from './chunk-MLKGABMK.js';
import { RuntimeContext } from '@mastra/core/di';
import { isVercelTool } from '@mastra/core/tools';

// src/server/handlers/tools.ts
var tools_exports = {};
__export(tools_exports, {
  executeAgentToolHandler: () => executeAgentToolHandler,
  executeToolHandler: () => executeToolHandler,
  getToolByIdHandler: () => getToolByIdHandler,
  getToolsHandler: () => getToolsHandler
});
async function getToolsHandler({ tools }) {
  try {
    if (!tools) {
      return {};
    }
    const serializedTools = Object.entries(tools).reduce(
      (acc, [id, _tool]) => {
        const tool = _tool;
        acc[id] = {
          ...tool,
          inputSchema: tool.inputSchema ? stringify(esm_default(tool.inputSchema)) : void 0,
          outputSchema: tool.outputSchema ? stringify(esm_default(tool.outputSchema)) : void 0
        };
        return acc;
      },
      {}
    );
    return serializedTools;
  } catch (error) {
    return handleError(error, "Error getting tools");
  }
}
async function getToolByIdHandler({ tools, toolId }) {
  try {
    const tool = Object.values(tools || {}).find((tool2) => tool2.id === toolId);
    if (!tool) {
      throw new HTTPException(404, { message: "Tool not found" });
    }
    const serializedTool = {
      ...tool,
      inputSchema: tool.inputSchema ? stringify(esm_default(tool.inputSchema)) : void 0,
      outputSchema: tool.outputSchema ? stringify(esm_default(tool.outputSchema)) : void 0
    };
    return serializedTool;
  } catch (error) {
    return handleError(error, "Error getting tool");
  }
}
function executeToolHandler(tools) {
  return async ({
    mastra,
    runId,
    toolId,
    data,
    runtimeContext,
    runtimeContextFromRequest
  }) => {
    try {
      if (!toolId) {
        throw new HTTPException(400, { message: "Tool ID is required" });
      }
      const tool = Object.values(tools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new HTTPException(400, { message: "Tool is not executable" });
      }
      validateBody({ data });
      if (isVercelTool(tool)) {
        const result2 = await tool.execute(data);
        return result2;
      }
      const finalRuntimeContext = new RuntimeContext([
        ...Array.from(runtimeContext.entries()),
        ...Array.from(Object.entries(runtimeContextFromRequest ?? {}))
      ]);
      const result = await tool.execute({
        context: data,
        mastra,
        runId,
        runtimeContext: finalRuntimeContext
      });
      return result;
    } catch (error) {
      return handleError(error, "Error executing tool");
    }
  };
}
async function executeAgentToolHandler({
  mastra,
  agentId,
  toolId,
  data,
  runtimeContext,
  runtimeContextFromRequest
}) {
  try {
    const agent = agentId ? mastra.getAgent(agentId) : null;
    if (!agent) {
      throw new HTTPException(404, { message: "Tool not found" });
    }
    const tool = Object.values(agent?.tools || {}).find((tool2) => tool2.id === toolId);
    if (!tool) {
      throw new HTTPException(404, { message: "Tool not found" });
    }
    if (!tool?.execute) {
      throw new HTTPException(400, { message: "Tool is not executable" });
    }
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(runtimeContextFromRequest ?? {}))
    ]);
    const result = await tool.execute({
      context: data,
      runtimeContext: finalRuntimeContext,
      mastra,
      runId: agentId
    });
    return result;
  } catch (error) {
    return handleError(error, "Error executing tool");
  }
}

export { executeAgentToolHandler, executeToolHandler, getToolByIdHandler, getToolsHandler, tools_exports };
