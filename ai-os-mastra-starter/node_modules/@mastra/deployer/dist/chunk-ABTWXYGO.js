import { recursiveRemoveNonReferencedNodes, removeAllOptionsFromMastraExcept } from './chunk-TUMXQX4H.js';
import { aliasHono } from './chunk-QJQ2V3Z2.js';
import { getInputOptions } from './chunk-AOSWYZKN.js';
import { tsConfigPaths } from './chunk-WVBUOQT6.js';
import { watch, rollup } from 'rollup';
import * as babel from '@babel/core';
import esbuild from 'rollup-plugin-esbuild';
import commonjs from '@rollup/plugin-commonjs';

async function getInputOptions2(entryFile, platform, env) {
  const inputOptions = await getInputOptions(
    entryFile,
    {
      dependencies: /* @__PURE__ */ new Map(),
      externalDependencies: /* @__PURE__ */ new Set(),
      invalidChunks: /* @__PURE__ */ new Set()
    },
    platform,
    env
  );
  if (Array.isArray(inputOptions.plugins)) {
    inputOptions.plugins = inputOptions.plugins.filter(
      // @ts-ignore
      (plugin) => !plugin || !plugin?.name || plugin.name !== "node-resolve"
    );
    inputOptions.plugins.push(aliasHono());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/babel/remove-all-options-server.ts
function removeAllOptionsExceptServer(result) {
  return removeAllOptionsFromMastraExcept(result, "server");
}
function getServerOptionsBundler(entryFile, result) {
  return rollup({
    logLevel: "silent",
    input: {
      "server-config": entryFile
    },
    treeshake: "smallest",
    plugins: [
      tsConfigPaths(),
      // transpile typescript to something we understand
      esbuild({
        target: "node20",
        platform: "node",
        minify: false
      }),
      commonjs({
        extensions: [".js", ".ts"],
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      {
        name: "get-server-config",
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return new Promise((resolve, reject) => {
            babel.transform(
              code,
              {
                babelrc: false,
                configFile: false,
                filename: id,
                plugins: [removeAllOptionsExceptServer(result)]
              },
              (err, result2) => {
                if (err) {
                  return reject(err);
                }
                resolve({
                  code: result2.code,
                  map: result2.map
                });
              }
            );
          });
        }
      },
      // let esbuild remove all unused imports
      esbuild({
        target: "node20",
        platform: "node",
        minify: false
      }),
      {
        name: "cleanup",
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return recursiveRemoveNonReferencedNodes(code);
        }
      },
      // let esbuild remove all unused imports
      esbuild({
        target: "node20",
        platform: "node",
        minify: false
      })
    ]
  });
}
async function getServerOptions(entryFile, outputDir) {
  const result = {
    hasCustomConfig: false
  };
  const bundle = await getServerOptionsBundler(entryFile, result);
  await bundle.write({
    dir: outputDir,
    format: "es",
    entryFileNames: "[name].mjs"
  });
  if (result.hasCustomConfig) {
    return (await import(`file:${outputDir}/server-config.mjs`)).server;
  }
  return null;
}

export { createWatcher, getInputOptions2 as getInputOptions, getServerOptions };
