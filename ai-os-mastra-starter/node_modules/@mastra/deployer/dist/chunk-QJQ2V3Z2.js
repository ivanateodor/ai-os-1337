import { tsConfigPaths, removeDeployer } from './chunk-WVBUOQT6.js';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import nodeResolve from '@rollup/plugin-node-resolve';
import virtual from '@rollup/plugin-virtual';
import { existsSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { rollup } from 'rollup';
import esbuild from 'rollup-plugin-esbuild';
import { builtinModules } from 'node:module';
import { join, dirname } from 'node:path';
import { spawn as spawn$1 } from 'node:child_process';
import { writeFile } from 'node:fs/promises';

function isNodeBuiltin(dep) {
  const [pkg] = dep.split("/");
  return dep.startsWith("node:") || builtinModules.includes(dep) || builtinModules.includes(pkg);
}
function aliasHono() {
  return {
    name: "hono-alias",
    resolveId(id) {
      if (!id.startsWith("@hono/") && !id.startsWith("hono/") && id !== "hono" && id !== "hono-openapi") {
        return;
      }
      const path = import.meta.resolve(id);
      return fileURLToPath(path);
    }
  };
}
function spawn(command, args = [], options = {}) {
  return new Promise((resolve, reject) => {
    const childProcess = spawn$1(command, args, {
      // stdio: 'inherit',
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    let stderr = "";
    childProcess.stderr?.on("data", (message) => {
      stderr += message;
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(stderr));
      }
    });
  });
}
function validate(file) {
  return spawn(
    "node",
    [
      "--import",
      import.meta.resolve("@mastra/deployer/loader"),
      "--input-type=module",
      "-e",
      `import('file://${file.replaceAll("\\", "/")}')`
    ],
    {
      cwd: dirname(file)
    }
  );
}
var globalExternals = ["pino", "pino-pretty", "@libsql/client", "pg", "libsql", "jsdom", "sqlite3"];
function findExternalImporter(module, external, allOutputs) {
  const capturedFiles = /* @__PURE__ */ new Set();
  for (const id of module.imports) {
    if (id === external) {
      return module;
    } else {
      if (id.endsWith(".mjs")) {
        capturedFiles.add(id);
      }
    }
  }
  for (const file of capturedFiles) {
    const nextModule = allOutputs.find((o) => o.fileName === file);
    if (nextModule) {
      const importer = findExternalImporter(nextModule, external, allOutputs);
      if (importer) {
        return importer;
      }
    }
  }
  return null;
}
async function analyze(entry, mastraEntry, isVirtualFile, platform, logger) {
  logger.info("Analyzing dependencies...");
  let virtualPlugin = null;
  if (isVirtualFile) {
    virtualPlugin = virtual({
      "#entry": entry
    });
    entry = "#entry";
  }
  const normalizedMastraEntry = mastraEntry.replaceAll("\\", "/");
  const optimizerBundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: isVirtualFile ? "#entry" : entry,
    treeshake: "smallest",
    preserveSymlinks: true,
    plugins: [
      virtualPlugin,
      tsConfigPaths(),
      {
        name: "custom-alias-resolver",
        resolveId(id) {
          if (id === "#server") {
            return fileURLToPath(import.meta.resolve("@mastra/deployer/server")).replaceAll("\\", "/");
          }
          if (id === "#mastra") {
            return normalizedMastraEntry;
          }
          if (id.startsWith("@mastra/server")) {
            return fileURLToPath(import.meta.resolve(id));
          }
        }
      },
      json(),
      esbuild({
        target: "node20",
        platform,
        minify: false
      }),
      commonjs({
        strictRequires: "debug",
        ignoreTryCatch: false,
        transformMixedEsModules: true,
        extensions: [".js", ".ts"]
      }),
      removeDeployer(normalizedMastraEntry),
      esbuild({
        target: "node20",
        platform,
        minify: false
      })
    ].filter(Boolean)
  });
  const { output } = await optimizerBundler.generate({
    format: "esm",
    inlineDynamicImports: true
  });
  await optimizerBundler.close();
  const depsToOptimize = new Map(Object.entries(output[0].importedBindings));
  for (const dep of depsToOptimize.keys()) {
    if (isNodeBuiltin(dep)) {
      depsToOptimize.delete(dep);
    }
  }
  for (const o of output) {
    if (o.type !== "chunk" || o.dynamicImports.length === 0) {
      continue;
    }
    for (const dynamicImport of o.dynamicImports) {
      if (!depsToOptimize.has(dynamicImport)) {
        depsToOptimize.set(dynamicImport, ["*"]);
      }
    }
  }
  return depsToOptimize;
}
async function bundleExternals(depsToOptimize, outputDir, logger) {
  logger.info("Optimizing dependencies...");
  logger.debug(
    `${Array.from(depsToOptimize.keys()).map((key) => `- ${key}`).join("\n")}`
  );
  const reverseVirtualReferenceMap = /* @__PURE__ */ new Map();
  const virtualDependencies = /* @__PURE__ */ new Map();
  for (const [dep, exports] of depsToOptimize.entries()) {
    const name = dep.replaceAll("/", "-");
    reverseVirtualReferenceMap.set(name, dep);
    const virtualFile = [];
    let exportStringBuilder = [];
    for (const local of exports) {
      if (local === "*") {
        virtualFile.push(`export * from '${dep}';`);
      } else if (local === "default") {
        virtualFile.push(`export { default } from '${dep}';`);
      } else {
        exportStringBuilder.push(local);
      }
    }
    if (exportStringBuilder.length > 0) {
      virtualFile.push(`export { ${exportStringBuilder.join(", ")} } from '${dep}';`);
    }
    virtualDependencies.set(dep, {
      name,
      virtual: virtualFile.join("\n")
    });
  }
  const bundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: Array.from(virtualDependencies.entries()).reduce(
      (acc, [dep, virtualDep]) => {
        acc[virtualDep.name] = `#virtual-${dep}`;
        return acc;
      },
      {}
    ),
    // this dependency breaks the build, so we need to exclude it
    // TODO actually fix this so we don't need to exclude it
    external: globalExternals,
    treeshake: "smallest",
    plugins: [
      virtual(
        Array.from(virtualDependencies.entries()).reduce(
          (acc, [dep, virtualDep]) => {
            acc[`#virtual-${dep}`] = virtualDep.virtual;
            return acc;
          },
          {}
        )
      ),
      commonjs({
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      nodeResolve({
        preferBuiltins: true,
        exportConditions: ["node", "import", "require"],
        mainFields: ["module", "main"]
      }),
      // hono is imported from deployer, so we need to resolve from here instead of the project root
      aliasHono(),
      json()
    ].filter(Boolean)
  });
  const { output } = await bundler.write({
    format: "esm",
    dir: outputDir,
    entryFileNames: "[name].mjs",
    chunkFileNames: "[name].mjs",
    hoistTransitiveImports: false
  });
  const moduleResolveMap = {};
  const filteredChunks = output.filter((o) => o.type === "chunk");
  for (const o of filteredChunks.filter((o2) => o2.isEntry || o2.isDynamicEntry)) {
    for (const external of globalExternals) {
      const importer = findExternalImporter(o, external, filteredChunks);
      if (importer) {
        const fullPath = join(outputDir, importer.fileName);
        moduleResolveMap[fullPath] = moduleResolveMap[fullPath] || {};
        if (importer.moduleIds.length) {
          moduleResolveMap[fullPath][external] = importer.moduleIds[importer.moduleIds.length - 1]?.startsWith(
            "\0virtual:#virtual"
          ) ? importer.moduleIds[importer.moduleIds.length - 2] : importer.moduleIds[importer.moduleIds.length - 1];
        }
      }
    }
  }
  await writeFile(join(outputDir, "module-resolve-map.json"), JSON.stringify(moduleResolveMap, null, 2));
  await bundler.close();
  return { output, reverseVirtualReferenceMap, usedExternals: moduleResolveMap };
}
async function validateOutput({
  output,
  reverseVirtualReferenceMap,
  usedExternals,
  outputDir
}, logger) {
  const result = {
    invalidChunks: /* @__PURE__ */ new Set(),
    dependencies: /* @__PURE__ */ new Map(),
    externalDependencies: /* @__PURE__ */ new Set()
  };
  for (const deps of Object.values(usedExternals)) {
    for (const dep of Object.keys(deps)) {
      result.externalDependencies.add(dep);
    }
  }
  for (const file of output) {
    if (file.type === "asset") {
      continue;
    }
    try {
      logger.debug(`Validating if ${file.fileName} is a valid module.`);
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        result.dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
      }
      if (!file.isDynamicEntry && file.isEntry) {
        await validate(join(outputDir, file.fileName));
      }
    } catch (err) {
      result.invalidChunks.add(file.fileName);
      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
        const reference = reverseVirtualReferenceMap.get(file.name);
        const dep = reference.startsWith("@") ? reference.split("/").slice(0, 2).join("/") : reference.split("/")[0];
        result.externalDependencies.add(dep);
      }
    }
  }
  return result;
}
async function analyzeBundle(entry, mastraEntry, outputDir, platform, logger) {
  const isVirtualFile = entry.includes("\n") || !existsSync(entry);
  const depsToOptimize = await analyze(entry, mastraEntry, isVirtualFile, platform, logger);
  const { output, reverseVirtualReferenceMap, usedExternals } = await bundleExternals(
    depsToOptimize,
    outputDir,
    logger
  );
  const result = await validateOutput({ output, reverseVirtualReferenceMap, usedExternals, outputDir }, logger);
  return result;
}

export { aliasHono, analyzeBundle };
