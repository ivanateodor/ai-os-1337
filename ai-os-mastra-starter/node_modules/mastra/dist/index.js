#! /usr/bin/env node
import { PosthogAnalytics } from './chunk-7OXWUU2Q.js';
export { PosthogAnalytics } from './chunk-7OXWUU2Q.js';
import { DepsService, create, checkPkgJson, checkAndInstallCoreDeps, interactivePrompt, init, logger, convertToViteEnvVar, FileService as FileService$1 } from './chunk-BY3FZLXQ.js';
export { create } from './chunk-BY3FZLXQ.js';
import { Command } from 'commander';
import { config } from 'dotenv';
import { join as join$1, dirname } from 'node:path';
import { getServerOptions, getWatcherInputOptions, writeTelemetryConfig, createWatcher, FileService as FileService$2 } from '@mastra/deployer/build';
import { Bundler } from '@mastra/deployer/bundler';
import { FileService, getDeployer } from '@mastra/deployer';
import { join } from 'path';
import { isWebContainer } from '@webcontainer/env';
import { execa } from 'execa';
import { writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import * as fsExtra from 'fs-extra';

var BuildBundler = class extends Bundler {
  constructor() {
    super("Build");
  }
  getEnvFiles() {
    const possibleFiles = [".env.production", ".env.local", ".env"];
    try {
      const fileService = new FileService$2();
      const envFile = fileService.getFirstExistingFile(possibleFiles);
      return Promise.resolve([envFile]);
    } catch (err) {
    }
    return Promise.resolve([]);
  }
  async prepare(outputDirectory) {
    await super.prepare(outputDirectory);
  }
  async bundle(entryFile, outputDirectory, toolsPaths) {
    return this._bundle(this.getEntry(), entryFile, outputDirectory, toolsPaths);
  }
  getEntry() {
    return `
    // @ts-ignore
    import { evaluate } from '@mastra/core/eval';
    import { AvailableHooks, registerHook } from '@mastra/core/hooks';
    import { TABLE_EVALS } from '@mastra/core/storage';
    import { checkEvalStorageFields } from '@mastra/core/utils';
    import { mastra } from '#mastra';
    import { createNodeServer } from '#server';
    // @ts-ignore
    await createNodeServer(mastra);

    registerHook(AvailableHooks.ON_GENERATION, ({ input, output, metric, runId, agentName, instructions }) => {
      evaluate({
        agentName,
        input,
        metric,
        output,
        runId,
        globalRunId: runId,
        instructions,
      });
    });

    if (mastra.getStorage()) {
      // start storage init in the background
      mastra.getStorage().init();
    }

    registerHook(AvailableHooks.ON_EVALUATION, async traceObject => {
      const storage = mastra.getStorage();
      if (storage) {
        // Check for required fields
        const logger = mastra?.getLogger();
        const areFieldsValid = checkEvalStorageFields(traceObject, logger);
        if (!areFieldsValid) return;

        await storage.insert({
          tableName: TABLE_EVALS,
          record: {
            input: traceObject.input,
            output: traceObject.output,
            result: JSON.stringify(traceObject.result || {}),
            agent_name: traceObject.agentName,
            metric_name: traceObject.metricName,
            instructions: traceObject.instructions,
            test_info: null,
            global_run_id: traceObject.globalRunId,
            run_id: traceObject.runId,
            created_at: new Date().toISOString(),
          },
        });
      }
    });
    `;
  }
};
async function build({ dir, tools }) {
  const mastraDir = dir ?? join$1(process.cwd(), "src", "mastra");
  const outputDirectory = join$1(process.cwd(), ".mastra");
  const defaultToolsPath = join$1(mastraDir, "tools");
  const discoveredTools = [defaultToolsPath, ...tools ?? []];
  try {
    const fs = new FileService$1();
    const mastraEntryFile = fs.getFirstExistingFile([join$1(mastraDir, "index.ts"), join$1(mastraDir, "index.js")]);
    const platformDeployer = await getDeployer(mastraEntryFile, outputDirectory);
    if (!platformDeployer) {
      const deployer = new BuildBundler();
      await deployer.prepare(outputDirectory);
      await deployer.bundle(mastraEntryFile, outputDirectory, discoveredTools);
      return;
    }
    logger.info("Deployer found, preparing deployer build...");
    await platformDeployer.prepare(outputDirectory);
    await platformDeployer.bundle(mastraEntryFile, outputDirectory, discoveredTools);
    logger.info("You can now deploy the .mastra/output directory to your target platform.");
  } catch (error) {
    if (error instanceof Error) {
      logger.debug(`error: ${error.message}`, { error });
    }
  }
}
async function deploy({ dir }) {
  let mastraDir = dir || join(process.cwd(), "src/mastra");
  try {
    const outputDirectory = join(process.cwd(), ".mastra");
    const fs = new FileService$1();
    const mastraEntryFile = fs.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
    const deployer = await getDeployer(mastraEntryFile, outputDirectory);
    if (!deployer) {
      logger.warn("No deployer found.");
      return;
    }
    try {
      await deployer.prepare(outputDirectory);
      await deployer.bundle(mastraEntryFile, outputDirectory, []);
      try {
        await deployer.deploy(outputDirectory);
      } catch (error) {
        console.error("[Mastra Deploy] - Error deploying:", error);
      }
    } catch (err) {
      if (err instanceof Error) {
        logger.debug(`error: ${err.message}`, { error: err });
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      logger.debug(`error: ${error.message}`, { error });
    }
    logger.warn("No deployer found.");
  }
}
var DevBundler = class extends Bundler {
  constructor() {
    super("Dev");
  }
  getEnvFiles() {
    const possibleFiles = [".env.development", ".env.local", ".env"];
    try {
      const fileService = new FileService();
      const envFile = fileService.getFirstExistingFile(possibleFiles);
      return Promise.resolve([envFile]);
    } catch {
    }
    return Promise.resolve([]);
  }
  async writePackageJson() {
  }
  async prepare(outputDirectory) {
    await super.prepare(outputDirectory);
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const playgroundServePath = join$1(outputDirectory, this.outputDir, "playground");
    await fsExtra.copy(join$1(dirname(__dirname), "src/playground/dist"), playgroundServePath, {
      overwrite: true
    });
  }
  async watch(entryFile, outputDirectory, toolsPaths) {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const envFiles = await this.getEnvFiles();
    const inputOptions = await getWatcherInputOptions(entryFile, "node", {
      "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "development")
    });
    const toolsInputOptions = await this.getToolsInputOptions(toolsPaths);
    await writeTelemetryConfig(entryFile, join$1(outputDirectory, this.outputDir));
    await this.writeInstrumentationFile(join$1(outputDirectory, this.outputDir));
    const outputDir = join$1(outputDirectory, this.outputDir);
    const copyPublic = this.copyPublic.bind(this);
    const watcher = await createWatcher(
      {
        ...inputOptions,
        plugins: [
          // @ts-ignore - types are good
          // eslint-disable-next-line @typescript-eslint/no-misused-promises
          ...inputOptions.plugins,
          {
            name: "env-watcher",
            buildStart() {
              for (const envFile of envFiles) {
                this.addWatchFile(envFile);
              }
            }
          },
          {
            name: "public-dir-watcher",
            buildStart() {
              this.addWatchFile(join$1(dirname(entryFile), "public"));
            },
            buildEnd() {
              return copyPublic(dirname(entryFile), outputDirectory);
            }
          },
          {
            name: "tools-watcher",
            async buildEnd() {
              const toolsInputOptions2 = Array.from(Object.keys(inputOptions.input || {})).filter((key) => key.startsWith("tools/")).map((key) => `./${key}.mjs`);
              await writeFile(
                join$1(outputDir, "tools.mjs"),
                `export const tools = ${JSON.stringify(toolsInputOptions2)};`
              );
            }
          }
        ],
        input: {
          index: join$1(__dirname, "templates", "dev.entry.js"),
          ...toolsInputOptions
        }
      },
      {
        dir: outputDir
      }
    );
    this.logger.info("Starting watcher...");
    return new Promise((resolve, reject) => {
      const cb = (event) => {
        if (event.code === "BUNDLE_END") {
          this.logger.info("Bundling finished, starting server...");
          watcher.off("event", cb);
          resolve(watcher);
        }
        if (event.code === "ERROR") {
          console.log(event);
          this.logger.error("Bundling failed, stopping watcher...");
          watcher.off("event", cb);
          reject(event);
        }
      };
      watcher.on("event", cb);
    });
  }
  async bundle() {
  }
};

// src/commands/dev/dev.ts
var currentServerProcess;
var isRestarting = false;
var startServer = async (dotMastraPath, port, env) => {
  try {
    logger.info("[Mastra Dev] - Starting server...");
    const commands = [];
    if (!isWebContainer()) {
      const instrumentation = import.meta.resolve("@opentelemetry/instrumentation/hook.mjs");
      commands.push("--import=./instrumentation.mjs", `--import=${instrumentation}`);
    }
    commands.push("index.mjs");
    currentServerProcess = execa("node", commands, {
      cwd: dotMastraPath,
      env: {
        NODE_ENV: "production",
        ...Object.fromEntries(env),
        MASTRA_DEV: "true",
        PORT: port.toString() || process.env.PORT || "4111",
        MASTRA_DEFAULT_STORAGE_URL: `file:${join(dotMastraPath, "..", "mastra.db")}`
      },
      stdio: "inherit",
      reject: false
    });
    if (currentServerProcess?.exitCode && currentServerProcess?.exitCode !== 0) {
      if (!currentServerProcess) {
        throw new Error(`Server failed to start`);
      }
      throw new Error(`Server failed to start with error: ${currentServerProcess.stderr}`);
    }
    await new Promise((resolve) => setTimeout(resolve, 1e3));
    try {
      await fetch(`http://localhost:${port}/__refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        }
      });
    } catch {
      await new Promise((resolve) => setTimeout(resolve, 1500));
      try {
        await fetch(`http://localhost:${port}/__refresh`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          }
        });
      } catch {
      }
    }
    if (currentServerProcess.exitCode !== null) {
      logger.error("Server failed to start with error:", { message: currentServerProcess.stderr });
      return;
    }
  } catch (err) {
    const execaError = err;
    if (execaError.stderr) logger.error("Server error output:", { stderr: execaError.stderr });
    if (execaError.stdout) logger.debug("Server output:", { stdout: execaError.stdout });
  }
};
async function rebundleAndRestart(dotMastraPath, port, bundler) {
  if (isRestarting) {
    return;
  }
  isRestarting = true;
  try {
    if (currentServerProcess) {
      logger.debug("Stopping current server...");
      currentServerProcess.kill("SIGINT");
    }
    const env = await bundler.loadEnvVars();
    await startServer(join(dotMastraPath, "output"), port, env);
  } finally {
    isRestarting = false;
  }
}
async function dev({
  port,
  dir,
  root,
  tools
}) {
  const rootDir = root || process.cwd();
  const mastraDir = join(rootDir, dir || "src/mastra");
  const dotMastraPath = join(rootDir, ".mastra");
  const defaultToolsPath = join(mastraDir, "tools");
  const discoveredTools = [defaultToolsPath, ...tools || []];
  const fileService = new FileService();
  const entryFile = fileService.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
  const bundler = new DevBundler();
  await bundler.prepare(dotMastraPath);
  const watcher = await bundler.watch(entryFile, dotMastraPath, discoveredTools);
  const env = await bundler.loadEnvVars();
  const formattedEnv = convertToViteEnvVar(env, ["MASTRA_TELEMETRY_DISABLED"]);
  const serverOptions = await getServerOptions(entryFile, join(dotMastraPath, "output"));
  const startPort = port ?? serverOptions?.port ?? 4111;
  await startServer(join(dotMastraPath, "output"), startPort, formattedEnv);
  watcher.on("event", (event) => {
    if (event.code === "BUNDLE_END") {
      logger.info("[Mastra Dev] - Bundling finished, restarting server...");
      rebundleAndRestart(dotMastraPath, startPort, bundler);
    }
  });
  process.on("SIGINT", () => {
    logger.info("[Mastra Dev] - Stopping server...");
    if (currentServerProcess) {
      currentServerProcess.kill();
    }
    watcher.close().catch(() => {
    }).finally(() => {
      process.exit(0);
    });
  });
}

// src/index.ts
var depsService = new DepsService();
var version = await depsService.getPackageVersion();
var analytics = new PosthogAnalytics({
  apiKey: "phc_SBLpZVAB6jmHOct9CABq3PF0Yn5FU3G2FgT4xUr2XrT",
  host: "https://us.posthog.com",
  version
});
var program = new Command();
var origin = process.env.MASTRA_ANALYTICS_ORIGIN;
program.version(`${version}`, "-v, --version").description(`Mastra CLI ${version}`).action(() => {
  try {
    analytics.trackCommand({
      command: "version",
      origin
    });
    console.log(`Mastra CLI: ${version}`);
  } catch {
  }
});
program.command("create").description("Create a new Mastra project").option("--default", "Quick start with defaults(src, OpenAI, no examples)").option("-c, --components <components>", "Comma-separated list of components (agents, tools, workflows)").option("-l, --llm <model-provider>", "Default model provider (openai, anthropic, groq, google, or cerebras))").option("-k, --llm-api-key <api-key>", "API key for the model provider").option("-e, --example", "Include example code").option("-t, --timeout [timeout]", "Configurable timeout for package installation, defaults to 60000 ms").option(
  "-p, --project-name <string>",
  "Project name that will be used in package.json and as the project directory name."
).action(async (args) => {
  await analytics.trackCommandExecution({
    command: "create",
    args,
    execution: async () => {
      const timeout = args?.timeout ? args?.timeout === true ? 6e4 : parseInt(args?.timeout, 10) : void 0;
      if (args.default) {
        await create({
          components: ["agents", "tools", "workflows"],
          llmProvider: "openai",
          addExample: false,
          timeout
        });
        return;
      }
      await create({
        components: args.components ? args.components.split(",") : [],
        llmProvider: args.llm,
        addExample: args.example,
        llmApiKey: args["llm-api-key"],
        timeout,
        projectName: args.projectName
      });
    },
    origin
  });
});
program.command("init").description("Initialize Mastra in your project").option("--default", "Quick start with defaults(src, OpenAI, no examples)").option("-d, --dir <directory>", "Directory for Mastra files to (defaults to src/)").option("-c, --components <components>", "Comma-separated list of components (agents, tools, workflows)").option("-l, --llm <model-provider>", "Default model provider (openai, anthropic, groq, google or cerebras))").option("-k, --llm-api-key <api-key>", "API key for the model provider").option("-e, --example", "Include example code").action(async (args) => {
  await analytics.trackCommandExecution({
    command: "init",
    args,
    execution: async () => {
      await checkPkgJson();
      await checkAndInstallCoreDeps();
      if (!Object.keys(args).length) {
        const result = await interactivePrompt();
        await init({
          ...result,
          llmApiKey: result?.llmApiKey
        });
        return;
      }
      if (args?.default) {
        await init({
          directory: "src/",
          components: ["agents", "tools", "workflows"],
          llmProvider: "openai",
          addExample: false
        });
        return;
      }
      const componentsArr = args.components ? args.components.split(",") : [];
      await init({
        directory: args.dir,
        components: componentsArr,
        llmProvider: args.llm,
        addExample: args.example,
        llmApiKey: args["llm-api-key"]
      });
      return;
    },
    origin
  });
});
program.command("dev").description("Start mastra server").option("-d, --dir <dir>", "Path to your mastra folder").option("-r, --root <root>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").option("-p, --port <port>", "deprecated: Port number for the development server (defaults to 4111)").action((args) => {
  analytics.trackCommand({
    command: "dev",
    origin
  });
  if (args?.port) {
    logger.warn("The --port option is deprecated. Use the server key in the Mastra instance instead.");
  }
  dev({
    port: args?.port ? parseInt(args.port) : null,
    dir: args?.dir,
    root: args?.root,
    tools: args?.tools ? args.tools.split(",") : []
  }).catch((err) => {
    logger.error(err.message);
  });
});
program.command("build").description("Build your Mastra project").option("-d, --dir <path>", "Path to directory").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").action(async (args) => {
  await analytics.trackCommandExecution({
    command: "mastra build",
    args,
    execution: async () => {
      await build({
        dir: args.dir,
        tools: args.tools ? args.tools.split(",") : []
      });
    },
    origin
  });
});
program.command("deploy").description("Deploy your Mastra project").option("-d, --dir <path>", "Path to directory").action(async (args) => {
  config({ path: [".env", ".env.production"] });
  await analytics.trackCommandExecution({
    command: "mastra deploy",
    args,
    execution: async () => {
      logger.warn(`DEPRECATED: The deploy command is deprecated.
          Please use the mastra build command instead.
          Then deploy .mastra/output to your target platform.
          `);
      await deploy({ dir: args.dir });
    },
    origin
  });
});
program.parse(process.argv);
